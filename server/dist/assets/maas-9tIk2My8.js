import{r as R,q as ot,W as Ee,o as Se,X as Zt,Y as Re}from"./index-B9BnOegz.js";var te={exports:{}},ee={};/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var at=R;function _e(t,n){return t===n&&(t!==0||1/t===1/n)||t!==t&&n!==n}var he=typeof Object.is=="function"?Object.is:_e,ge=at.useState,ve=at.useEffect,Te=at.useLayoutEffect,pe=at.useDebugValue;function me(t,n){var e=n(),o=ge({inst:{value:e,getSnapshot:n}}),s=o[0].inst,i=o[1];return Te(function(){s.value=e,s.getSnapshot=n,bt(s)&&i({inst:s})},[t,e,n]),ve(function(){return bt(s)&&i({inst:s}),t(function(){bt(s)&&i({inst:s})})},[t]),pe(e),e}function bt(t){var n=t.getSnapshot;t=t.value;try{var e=n();return!he(t,e)}catch{return!0}}function Ie(t,n){return n()}var Oe=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?Ie:me;ee.useSyncExternalStore=at.useSyncExternalStore!==void 0?at.useSyncExternalStore:Oe;te.exports=ee;var ne=te.exports;const et=()=>{},b=et(),Lt=Object,u=t=>t===b,H=t=>typeof t=="function",J=(t,n)=>({...t,...n}),Ae=t=>H(t.then),mt=new WeakMap;let we=0;const vt=t=>{const n=typeof t,e=t&&t.constructor,o=e==Date;let s,i;if(Lt(t)===t&&!o&&e!=RegExp){if(s=mt.get(t),s)return s;if(s=++we+"~",mt.set(t,s),e==Array){for(s="@",i=0;i<t.length;i++)s+=vt(t[i])+",";mt.set(t,s)}if(e==Lt){s="#";const S=Lt.keys(t).sort();for(;!u(i=S.pop());)u(t[i])||(s+=i+":"+vt(t[i])+",");mt.set(t,s)}}else s=o?t.toJSON():n=="symbol"?t.toString():n=="string"?JSON.stringify(t):""+t;return s},G=new WeakMap,Nt={},It={},Bt="undefined",At=typeof window!=Bt,xt=typeof document!=Bt,De=()=>At&&typeof window.requestAnimationFrame!=Bt,Ht=(t,n)=>{const e=G.get(t);return[()=>!u(n)&&t.get(n)||Nt,o=>{if(!u(n)){const s=t.get(n);n in It||(It[n]=s),e[5](n,J(s,o),s||Nt)}},e[6],()=>!u(n)&&n in It?It[n]:!u(n)&&t.get(n)||Nt]};let Wt=!0;const ye=()=>Wt,[kt,qt]=At&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[et,et],Ce=()=>{const t=xt&&document.visibilityState;return u(t)||t!=="hidden"},Ve=t=>(xt&&document.addEventListener("visibilitychange",t),kt("focus",t),()=>{xt&&document.removeEventListener("visibilitychange",t),qt("focus",t)}),be=t=>{const n=()=>{Wt=!0,t()},e=()=>{Wt=!1};return kt("online",n),kt("offline",e),()=>{qt("online",n),qt("offline",e)}},Le={isOnline:ye,isVisible:Ce},Ne={initFocus:Ve,initReconnect:be},Tt=!ot.useId,it=!At||"Deno"in window,re=t=>De()?window.requestAnimationFrame(t):setTimeout(t,1),nt=it?R.useEffect:R.useLayoutEffect,Mt=typeof navigator<"u"&&navigator.connection,zt=!it&&Mt&&(["slow-2g","2g"].includes(Mt.effectiveType)||Mt.saveData),pt=t=>{if(H(t))try{t=t()}catch{t=""}const n=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?vt(t):"",[t,n]};let Me=0;const ct=()=>++Me,se=0,oe=1,ie=2,Fe=3;var X={__proto__:null,ERROR_REVALIDATE_EVENT:Fe,FOCUS_EVENT:se,MUTATE_EVENT:ie,RECONNECT_EVENT:oe};async function Jt(...t){const[n,e,o,s]=t,i=J({populateCache:!0,throwOnError:!0},typeof s=="boolean"?{revalidate:s}:s||{});let S=i.populateCache;const c=i.rollbackOnError;let _=i.optimisticData;const p=A=>typeof c=="function"?c(A):c!==!1,a=i.throwOnError;if(H(e)){const A=e,h=[],L=n.keys();for(const d of L)!/^\$(inf|sub)\$/.test(d)&&A(n.get(d)._k)&&h.push(d);return Promise.all(h.map(v))}return v(e);async function v(A){const[h]=pt(A);if(!h)return;const[L,d]=Ht(n,h),[y,r,I,U]=G.get(n),D=()=>{const x=y[h];return(H(i.revalidate)?i.revalidate(L().data,A):i.revalidate!==!1)&&(delete I[h],delete U[h],x&&x[0])?x[0](ie).then(()=>L().data):L().data};if(t.length<3)return D();let C=o,P;const K=ct();r[h]=[K,0];const g=!u(_),$=L(),F=$.data,Y=$._c,Q=u(Y)?F:Y;if(g&&(_=H(_)?_(Q,F):_,d({data:_,_c:Q})),H(C))try{C=C(Q)}catch(x){P=x}if(C&&Ae(C))if(C=await C.catch(x=>{P=x}),K!==r[h][0]){if(P)throw P;return C}else P&&g&&p(P)&&(S=!0,d({data:Q,_c:b}));if(S&&!P)if(H(S)){const x=S(C,Q);d({data:x,error:b,_c:b})}else d({data:C,error:b,_c:b});if(r[h][1]=ct(),Promise.resolve(D()).then(()=>{d({_c:b})}),P){if(a)throw P;return}return C}}const Kt=(t,n)=>{for(const e in t)t[e][0]&&t[e][0](n)},Ue=(t,n)=>{if(!G.has(t)){const e=J(Ne,n),o={},s=Jt.bind(b,t);let i=et;const S={},c=(a,v)=>{const A=S[a]||[];return S[a]=A,A.push(v),()=>A.splice(A.indexOf(v),1)},_=(a,v,A)=>{t.set(a,v);const h=S[a];if(h)for(const L of h)L(v,A)},p=()=>{if(!G.has(t)&&(G.set(t,[o,{},{},{},s,_,c]),!it)){const a=e.initFocus(setTimeout.bind(b,Kt.bind(b,o,se))),v=e.initReconnect(setTimeout.bind(b,Kt.bind(b,o,oe)));i=()=>{a&&a(),v&&v(),G.delete(t)}}};return p(),[t,s,p,i]}return[t,G.get(t)[4]]},Pe=(t,n,e,o,s)=>{const i=e.errorRetryCount,S=s.retryCount,c=~~((Math.random()+.5)*(1<<(S<8?S:8)))*e.errorRetryInterval;!u(i)&&S>i||setTimeout(o,c,s)},xe=(t,n)=>vt(t)==vt(n),[ae,We]=Ue(new Map),ke=J({onLoadingSlow:et,onSuccess:et,onError:et,onErrorRetry:Pe,onDiscarded:et,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:zt?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:zt?5e3:3e3,compare:xe,isPaused:()=>!1,cache:ae,mutate:We,fallback:{}},Le),qe=(t,n)=>{const e=J(t,n);if(n){const{use:o,fallback:s}=t,{use:i,fallback:S}=n;o&&i&&(e.use=o.concat(i)),s&&S&&(e.fallback=J(s,S))}return e},je=R.createContext({}),Be="$inf$",ce=At&&window.__SWR_DEVTOOLS_USE__,He=ce?window.__SWR_DEVTOOLS_USE__:[],Je=()=>{ce&&(window.__SWR_DEVTOOLS_REACT__=ot)},ue=t=>H(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],le=()=>J(ke,R.useContext(je)),ze=t=>(n,e,o)=>t(n,e&&((...i)=>{const[S]=pt(n),[,,,c]=G.get(ae);if(S.startsWith(Be))return e(...i);const _=c[S];return u(_)?e(...i):(delete c[S],_)}),o),Ke=He.concat(ze),fe=t=>function(...e){const o=le(),[s,i,S]=ue(e),c=qe(o,S);let _=t;const{use:p}=c,a=(p||[]).concat(Ke);for(let v=a.length;v--;)_=a[v](_);return _(s,i||c.fetcher||null,c)},de=(t,n,e)=>{const o=n[t]||(n[t]=[]);return o.push(e),()=>{const s=o.indexOf(e);s>=0&&(o[s]=o[o.length-1],o.pop())}},$e=(t,n)=>(...e)=>{const[o,s,i]=ue(e),S=(i.use||[]).concat(n);return t(o,s,{...i,use:S})};Je();const $t=ot.use||(t=>{if(t.status==="pending")throw t;if(t.status==="fulfilled")return t.value;throw t.status==="rejected"?t.reason:(t.status="pending",t.then(n=>{t.status="fulfilled",t.value=n},n=>{t.status="rejected",t.reason=n}),t)}),Ft={dedupe:!0},Ye=(t,n,e)=>{const{cache:o,compare:s,suspense:i,fallbackData:S,revalidateOnMount:c,revalidateIfStale:_,refreshInterval:p,refreshWhenHidden:a,refreshWhenOffline:v,keepPreviousData:A}=e,[h,L,d,y]=G.get(o),[r,I]=pt(t),U=R.useRef(!1),D=R.useRef(!1),C=R.useRef(r),P=R.useRef(n),K=R.useRef(e),g=()=>K.current,$=()=>g().isVisible()&&g().isOnline(),[F,Y,Q,x]=Ht(o,r),B=R.useRef({}).current,wt=u(S)?e.fallback[r]:S,ut=(l,f)=>{for(const m in B){const E=m;if(E==="data"){if(!s(l[E],f[E])&&(!u(l[E])||!s(tt,f[E])))return!1}else if(f[E]!==l[E])return!1}return!0},lt=R.useMemo(()=>{const l=!r||!n?!1:u(c)?g().isPaused()||i?!1:u(_)?!0:_:c,f=O=>{const N=J(O);return delete N._k,l?{isValidating:!0,isLoading:!0,...N}:N},m=F(),E=x(),V=f(m),j=m===E?V:f(E);let T=V;return[()=>{const O=f(F());return ut(O,T)?(T.data=O.data,T.isLoading=O.isLoading,T.isValidating=O.isValidating,T.error=O.error,T):(T=O,O)},()=>j]},[o,r]),W=ne.useSyncExternalStore(R.useCallback(l=>Q(r,(f,m)=>{ut(m,f)||l()}),[o,r]),lt[0],lt[1]),ft=!U.current,Dt=h[r]&&h[r].length>0,k=W.data,q=u(k)?wt:k,Z=W.error,dt=R.useRef(q),tt=A?u(k)?dt.current:k:q,Et=Dt&&!u(Z)?!1:ft&&!u(c)?c:g().isPaused()?!1:i?u(q)?!1:_:u(q)||_,St=!!(r&&n&&ft&&Et),yt=u(W.isValidating)?St:W.isValidating,Ct=u(W.isLoading)?St:W.isLoading,z=R.useCallback(async l=>{const f=P.current;if(!r||!f||D.current||g().isPaused())return!1;let m,E,V=!0;const j=l||{},T=!d[r]||!j.dedupe,O=()=>Tt?!D.current&&r===C.current&&U.current:r===C.current,N={isValidating:!1,isLoading:!1},_t=()=>{Y(N)},ht=()=>{const w=d[r];w&&w[1]===E&&delete d[r]},gt={isValidating:!0};u(F().data)&&(gt.isLoading=!0);try{if(T&&(Y(gt),e.loadingTimeout&&u(F().data)&&setTimeout(()=>{V&&O()&&g().onLoadingSlow(r,e)},e.loadingTimeout),d[r]=[f(I),ct()]),[m,E]=d[r],m=await m,T&&setTimeout(ht,e.dedupingInterval),!d[r]||d[r][1]!==E)return T&&O()&&g().onDiscarded(r),!1;N.error=b;const w=L[r];if(!u(w)&&(E<=w[0]||E<=w[1]||w[1]===0))return _t(),T&&O()&&g().onDiscarded(r),!1;const M=F().data;N.data=s(M,m)?M:m,T&&O()&&g().onSuccess(m,r,e)}catch(w){ht();const M=g(),{shouldRetryOnError:rt}=M;M.isPaused()||(N.error=w,T&&O()&&(M.onError(w,r,M),(rt===!0||H(rt)&&rt(w))&&(!g().revalidateOnFocus||!g().revalidateOnReconnect||$())&&M.onErrorRetry(w,r,M,Vt=>{const st=h[r];st&&st[0]&&st[0](X.ERROR_REVALIDATE_EVENT,Vt)},{retryCount:(j.retryCount||0)+1,dedupe:!0})))}return V=!1,_t(),!0},[r,o]),Rt=R.useCallback((...l)=>Jt(o,C.current,...l),[]);if(nt(()=>{P.current=n,K.current=e,u(k)||(dt.current=k)}),nt(()=>{if(!r)return;const l=z.bind(b,Ft);let f=0;const E=de(r,h,(V,j={})=>{if(V==X.FOCUS_EVENT){const T=Date.now();g().revalidateOnFocus&&T>f&&$()&&(f=T+g().focusThrottleInterval,l())}else if(V==X.RECONNECT_EVENT)g().revalidateOnReconnect&&$()&&l();else{if(V==X.MUTATE_EVENT)return z();if(V==X.ERROR_REVALIDATE_EVENT)return z(j)}});return D.current=!1,C.current=r,U.current=!0,Y({_k:I}),Et&&(u(q)||it?l():re(l)),()=>{D.current=!0,E()}},[r]),nt(()=>{let l;function f(){const E=H(p)?p(F().data):p;E&&l!==-1&&(l=setTimeout(m,E))}function m(){!F().error&&(a||g().isVisible())&&(v||g().isOnline())?z(Ft).then(f):f()}return f(),()=>{l&&(clearTimeout(l),l=-1)}},[p,a,v,r]),R.useDebugValue(tt),i&&u(q)&&r){if(!Tt&&it)throw new Error("Fallback data is required when using suspense in SSR.");P.current=n,K.current=e,D.current=!1;const l=y[r];if(!u(l)){const f=Rt(l);$t(f)}if(u(Z)){const f=z(Ft);u(tt)||(f.status="fulfilled",f.value=!0),$t(f)}else throw Z}return{mutate:Rt,get data(){return B.data=!0,tt},get error(){return B.error=!0,Z},get isValidating(){return B.isValidating=!0,yt},get isLoading(){return B.isLoading=!0,Ct}}},Ge=fe(Ye),Yt=ot.use||(t=>{if(t.status==="pending")throw t;if(t.status==="fulfilled")return t.value;throw t.status==="rejected"?t.reason:(t.status="pending",t.then(n=>{t.status="fulfilled",t.value=n},n=>{t.status="rejected",t.reason=n}),t)}),Ut={dedupe:!0},Xe=(t,n,e)=>{const{cache:o,compare:s,suspense:i,fallbackData:S,revalidateOnMount:c,revalidateIfStale:_,refreshInterval:p,refreshWhenHidden:a,refreshWhenOffline:v,keepPreviousData:A}=e,[h,L,d,y]=G.get(o),[r,I]=pt(t),U=R.useRef(!1),D=R.useRef(!1),C=R.useRef(r),P=R.useRef(n),K=R.useRef(e),g=()=>K.current,$=()=>g().isVisible()&&g().isOnline(),[F,Y,Q,x]=Ht(o,r),B=R.useRef({}).current,wt=u(S)?e.fallback[r]:S,ut=(l,f)=>{for(const m in B){const E=m;if(E==="data"){if(!s(l[E],f[E])&&(!u(l[E])||!s(tt,f[E])))return!1}else if(f[E]!==l[E])return!1}return!0},lt=R.useMemo(()=>{const l=!r||!n?!1:u(c)?g().isPaused()||i?!1:u(_)?!0:_:c,f=O=>{const N=J(O);return delete N._k,l?{isValidating:!0,isLoading:!0,...N}:N},m=F(),E=x(),V=f(m),j=m===E?V:f(E);let T=V;return[()=>{const O=f(F());return ut(O,T)?(T.data=O.data,T.isLoading=O.isLoading,T.isValidating=O.isValidating,T.error=O.error,T):(T=O,O)},()=>j]},[o,r]),W=ne.useSyncExternalStore(R.useCallback(l=>Q(r,(f,m)=>{ut(m,f)||l()}),[o,r]),lt[0],lt[1]),ft=!U.current,Dt=h[r]&&h[r].length>0,k=W.data,q=u(k)?wt:k,Z=W.error,dt=R.useRef(q),tt=A?u(k)?dt.current:k:q,Et=Dt&&!u(Z)?!1:ft&&!u(c)?c:g().isPaused()?!1:i?u(q)?!1:_:u(q)||_,St=!!(r&&n&&ft&&Et),yt=u(W.isValidating)?St:W.isValidating,Ct=u(W.isLoading)?St:W.isLoading,z=R.useCallback(async l=>{const f=P.current;if(!r||!f||D.current||g().isPaused())return!1;let m,E,V=!0;const j=l||{},T=!d[r]||!j.dedupe,O=()=>Tt?!D.current&&r===C.current&&U.current:r===C.current,N={isValidating:!1,isLoading:!1},_t=()=>{Y(N)},ht=()=>{const w=d[r];w&&w[1]===E&&delete d[r]},gt={isValidating:!0};u(F().data)&&(gt.isLoading=!0);try{if(T&&(Y(gt),e.loadingTimeout&&u(F().data)&&setTimeout(()=>{V&&O()&&g().onLoadingSlow(r,e)},e.loadingTimeout),d[r]=[f(I),ct()]),[m,E]=d[r],m=await m,T&&setTimeout(ht,e.dedupingInterval),!d[r]||d[r][1]!==E)return T&&O()&&g().onDiscarded(r),!1;N.error=b;const w=L[r];if(!u(w)&&(E<=w[0]||E<=w[1]||w[1]===0))return _t(),T&&O()&&g().onDiscarded(r),!1;const M=F().data;N.data=s(M,m)?M:m,T&&O()&&g().onSuccess(m,r,e)}catch(w){ht();const M=g(),{shouldRetryOnError:rt}=M;M.isPaused()||(N.error=w,T&&O()&&(M.onError(w,r,M),(rt===!0||H(rt)&&rt(w))&&(!g().revalidateOnFocus||!g().revalidateOnReconnect||$())&&M.onErrorRetry(w,r,M,Vt=>{const st=h[r];st&&st[0]&&st[0](X.ERROR_REVALIDATE_EVENT,Vt)},{retryCount:(j.retryCount||0)+1,dedupe:!0})))}return V=!1,_t(),!0},[r,o]),Rt=R.useCallback((...l)=>Jt(o,C.current,...l),[]);if(nt(()=>{P.current=n,K.current=e,u(k)||(dt.current=k)}),nt(()=>{if(!r)return;const l=z.bind(b,Ut);let f=0;const E=de(r,h,(V,j={})=>{if(V==X.FOCUS_EVENT){const T=Date.now();g().revalidateOnFocus&&T>f&&$()&&(f=T+g().focusThrottleInterval,l())}else if(V==X.RECONNECT_EVENT)g().revalidateOnReconnect&&$()&&l();else{if(V==X.MUTATE_EVENT)return z();if(V==X.ERROR_REVALIDATE_EVENT)return z(j)}});return D.current=!1,C.current=r,U.current=!0,Y({_k:I}),Et&&(u(q)||it?l():re(l)),()=>{D.current=!0,E()}},[r]),nt(()=>{let l;function f(){const E=H(p)?p(F().data):p;E&&l!==-1&&(l=setTimeout(m,E))}function m(){!F().error&&(a||g().isVisible())&&(v||g().isOnline())?z(Ut).then(f):f()}return f(),()=>{l&&(clearTimeout(l),l=-1)}},[p,a,v,r]),R.useDebugValue(tt),i&&u(q)&&r){if(!Tt&&it)throw new Error("Fallback data is required when using suspense in SSR.");P.current=n,K.current=e,D.current=!1;const l=y[r];if(!u(l)){const f=Rt(l);Yt(f)}if(u(Z)){const f=z(Ut);u(tt)||(f.status="fulfilled",f.value=!0),Yt(f)}else throw Z}return{mutate:Rt,get data(){return B.data=!0,tt},get error(){return B.error=!0,Z},get isValidating(){return B.isValidating=!0,yt},get isLoading(){return B.isLoading=!0,Ct}}},Qe=fe(Xe),Gt=Tt?t=>{t()}:ot.startTransition,Ze=t=>{const[,n]=R.useState({}),e=R.useRef(!1),o=R.useRef(t),s=R.useRef({data:!1,error:!1,isValidating:!1}),i=R.useCallback(S=>{let c=!1;const _=o.current;for(const p in S){const a=p;_[a]!==S[a]&&(_[a]=S[a],s.current[a]&&(c=!0))}c&&!e.current&&n({})},[]);return nt(()=>(e.current=!1,()=>{e.current=!0})),[o,s.current,i]},tn=()=>(t,n,e={})=>{const{mutate:o}=le(),s=R.useRef(t),i=R.useRef(n),S=R.useRef(e),c=R.useRef(0),[_,p,a]=Ze({data:b,error:b,isMutating:!1}),v=_.current,A=R.useCallback(async(L,d)=>{const[y,r]=pt(s.current);if(!i.current)throw new Error("Can’t trigger the mutation: missing fetcher.");if(!y)throw new Error("Can’t trigger the mutation: missing key.");const I=J(J({populateCache:!1,throwOnError:!0},S.current),d),U=ct();c.current=U,a({isMutating:!0});try{const D=await o(y,i.current(r,{arg:L}),J(I,{throwOnError:!0}));return c.current<=U&&(Gt(()=>a({data:D,isMutating:!1,error:void 0})),I.onSuccess==null||I.onSuccess.call(I,D,y,I)),D}catch(D){if(c.current<=U&&(Gt(()=>a({error:D,isMutating:!1})),I.onError==null||I.onError.call(I,D,y,I),I.throwOnError))throw D}},[]),h=R.useCallback(()=>{c.current=ct(),a({data:b,error:b,isMutating:!1})},[]);return nt(()=>{s.current=t,i.current=n,S.current=e}),{trigger:A,reset:h,get data(){return p.data=!0,v.data},get error(){return p.error=!0,v.error},get isMutating(){return p.isMutating=!0,v.isMutating}}},en=$e(Qe,tn),Xt=t=>{let n;const e=new Set,o=(p,a)=>{const v=typeof p=="function"?p(n):p;if(!Object.is(v,n)){const A=n;n=a??(typeof v!="object"||v===null)?v:Object.assign({},n,v),e.forEach(h=>h(n,A))}},s=()=>n,c={setState:o,getState:s,getInitialState:()=>_,subscribe:p=>(e.add(p),()=>e.delete(p))},_=n=t(o,s,c);return c},nn=t=>t?Xt(t):Xt,rn=t=>t;function sn(t,n=rn){const e=ot.useSyncExternalStore(t.subscribe,()=>n(t.getState()),()=>n(t.getInitialState()));return ot.useDebugValue(e),e}const on=t=>{const n=nn(t),e=o=>sn(n,o);return Object.assign(e,n),e},an=t=>on,Qt={BASE_URL:"/",DEV:!1,MODE:"production",PROD:!0,SSR:!1,VITE_ASSET_URL:"https://api-dev-minimal-v6.vercel.app",VITE_AUTH0_CALLBACK_URL:"",VITE_AUTH0_CLIENT_ID:"",VITE_AUTH0_DOMAIN:"",VITE_AWS_AMPLIFY_REGION:"",VITE_AWS_AMPLIFY_USER_POOL_ID:"",VITE_AWS_AMPLIFY_USER_POOL_WEB_CLIENT_ID:"",VITE_BASE_PATH:"",VITE_FIREBASE_API_KEY:"",VITE_FIREBASE_APPID:"",VITE_FIREBASE_AUTH_DOMAIN:"",VITE_FIREBASE_MESSAGING_SENDER_ID:"",VITE_FIREBASE_PROJECT_ID:"",VITE_FIREBASE_STORAGE_BUCKET:"",VITE_MAPBOX_API_KEY:"",VITE_SERVER_URL:"/api/v1",VITE_SUPABASE_ANON_KEY:"",VITE_SUPABASE_URL:""},jt=new Map,Ot=t=>{const n=jt.get(t);return n?Object.fromEntries(Object.entries(n.stores).map(([e,o])=>[e,o.getState()])):{}},cn=(t,n,e)=>{if(t===void 0)return{type:"untracked",connection:n.connect(e)};const o=jt.get(e.name);if(o)return{type:"tracked",store:t,...o};const s={connection:n.connect(e),stores:{}};return jt.set(e.name,s),{type:"tracked",store:t,...s}},un=(t,n={})=>(e,o,s)=>{const{enabled:i,anonymousActionType:S,store:c,..._}=n;let p;try{p=(i??(Qt?"production":void 0)!=="production")&&window.__REDUX_DEVTOOLS_EXTENSION__}catch{}if(!p)return t(e,o,s);const{connection:a,...v}=cn(c,p,_);let A=!0;s.setState=(d,y,r)=>{const I=e(d,y);if(!A)return I;const U=r===void 0?{type:S||"anonymous"}:typeof r=="string"?{type:r}:r;return c===void 0?(a==null||a.send(U,o()),I):(a==null||a.send({...U,type:`${c}/${U.type}`},{...Ot(_.name),[c]:s.getState()}),I)};const h=(...d)=>{const y=A;A=!1,e(...d),A=y},L=t(s.setState,o,s);if(v.type==="untracked"?a==null||a.init(L):(v.stores[v.store]=s,a==null||a.init(Object.fromEntries(Object.entries(v.stores).map(([d,y])=>[d,d===v.store?L:y.getState()])))),s.dispatchFromDevtools&&typeof s.dispatch=="function"){let d=!1;const y=s.dispatch;s.dispatch=(...r)=>{(Qt?"production":void 0)!=="production"&&r[0].type==="__setState"&&!d&&(console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'),d=!0),y(...r)}}return a.subscribe(d=>{var y;switch(d.type){case"ACTION":if(typeof d.payload!="string"){console.error("[zustand devtools middleware] Unsupported action format");return}return Pt(d.payload,r=>{if(r.type==="__setState"){if(c===void 0){h(r.state);return}Object.keys(r.state).length!==1&&console.error(`
                    [zustand devtools middleware] Unsupported __setState action format.
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);const I=r.state[c];if(I==null)return;JSON.stringify(s.getState())!==JSON.stringify(I)&&h(I);return}s.dispatchFromDevtools&&typeof s.dispatch=="function"&&s.dispatch(r)});case"DISPATCH":switch(d.payload.type){case"RESET":return h(L),c===void 0?a==null?void 0:a.init(s.getState()):a==null?void 0:a.init(Ot(_.name));case"COMMIT":if(c===void 0){a==null||a.init(s.getState());return}return a==null?void 0:a.init(Ot(_.name));case"ROLLBACK":return Pt(d.state,r=>{if(c===void 0){h(r),a==null||a.init(s.getState());return}h(r[c]),a==null||a.init(Ot(_.name))});case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return Pt(d.state,r=>{if(c===void 0){h(r);return}JSON.stringify(s.getState())!==JSON.stringify(r[c])&&h(r[c])});case"IMPORT_STATE":{const{nextLiftedState:r}=d.payload,I=(y=r.computedStates.slice(-1)[0])==null?void 0:y.state;if(!I)return;h(c===void 0?I:I[c]),a==null||a.send(null,r);return}case"PAUSE_RECORDING":return A=!A}return}}),L},ln=un,Pt=(t,n)=>{let e;try{e=JSON.parse(t)}catch(o){console.error("[zustand devtools middleware] Could not parse the received json",o)}e!==void 0&&n(e)},fn={maasList:[]},dn=an()(ln((t,n)=>({...fn,setMaasList(e){t({maasList:e})}})));function Sn(){const t=Zt.maas.list,{setMaasList:n}=dn(),{data:e,isLoading:o,error:s,isValidating:i}=Ge(t,Ee);return R.useEffect(()=>{Se.isArray(e==null?void 0:e.payload)&&n(e.payload)},[e,n]),R.useMemo(()=>{var c;return{maasList:(e==null?void 0:e.payload)||[],modelListLoading:o,modelListError:s,modelListValidating:i,modelListEmpty:!o&&!((c=e==null?void 0:e.payload)!=null&&c.length)}},[e,o,s,i])}const Rn=()=>{const t=Zt.maas.create;async function n(s,{arg:i}){return Re(s,i)}const{trigger:e,isMutating:o}=en(t,n,{onSuccess:(s,i)=>console.log("onSuccess",s,i),onError:(s,i)=>console.log("onError",s,i)});return{trigger:e,isMutating:o}};export{Ge as a,Sn as b,Rn as c,en as u};
