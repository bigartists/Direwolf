import{r as d,v as mt,bE as ue,bF as Bt,bG as ce}from"./index-CyQALytQ.js";var Jt={exports:{}},Yt={};/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var it=d;function le(t,e){return t===e&&(t!==0||1/t===1/e)||t!==t&&e!==e}var fe=typeof Object.is=="function"?Object.is:le,de=it.useState,Ee=it.useEffect,Re=it.useLayoutEffect,he=it.useDebugValue;function ge(t,e){var n=e(),i=de({inst:{value:n,getSnapshot:e}}),s=i[0].inst,o=i[1];return Re(function(){s.value=n,s.getSnapshot=e,At(s)&&o({inst:s})},[t,n,e]),Ee(function(){return At(s)&&o({inst:s}),t(function(){At(s)&&o({inst:s})})},[t]),he(n),n}function At(t){var e=t.getSnapshot;t=t.value;try{var n=e();return!fe(t,n)}catch{return!0}}function Se(t,e){return e()}var ve=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?Se:ge;Yt.useSyncExternalStore=it.useSyncExternalStore!==void 0?it.useSyncExternalStore:ve;Jt.exports=Yt;var Xt=Jt.exports;const et=()=>{},b=et(),yt=Object,a=t=>t===b,$=t=>typeof t=="function",j=(t,e)=>({...t,...e}),Te=t=>$(t.then),pt=new WeakMap;let me=0;const vt=t=>{const e=typeof t,n=t&&t.constructor,i=n==Date;let s,o;if(yt(t)===t&&!i&&n!=RegExp){if(s=pt.get(t),s)return s;if(s=++me+"~",pt.set(t,s),n==Array){for(s="@",o=0;o<t.length;o++)s+=vt(t[o])+",";pt.set(t,s)}if(n==yt){s="#";const f=yt.keys(t).sort();for(;!a(o=f.pop());)a(t[o])||(s+=o+":"+vt(t[o])+",");pt.set(t,s)}}else s=i?t.toJSON():e=="symbol"?t.toString():e=="string"?JSON.stringify(t):""+t;return s},Y=new WeakMap,It={},_t={},Pt="undefined",Dt=typeof window!=Pt,xt=typeof document!=Pt,we=()=>Dt&&typeof window.requestAnimationFrame!=Pt,qt=(t,e)=>{const n=Y.get(t);return[()=>!a(e)&&t.get(e)||It,i=>{if(!a(e)){const s=t.get(e);e in _t||(_t[e]=s),n[5](e,j(s,i),s||It)}},n[6],()=>!a(e)&&e in _t?_t[e]:!a(e)&&t.get(e)||It]};let Wt=!0;const pe=()=>Wt,[Ut,kt]=Dt&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[et,et],_e=()=>{const t=xt&&document.visibilityState;return a(t)||t!=="hidden"},De=t=>(xt&&document.addEventListener("visibilitychange",t),Ut("focus",t),()=>{xt&&document.removeEventListener("visibilitychange",t),kt("focus",t)}),Ce=t=>{const e=()=>{Wt=!0,t()},n=()=>{Wt=!1};return Ut("online",e),Ut("offline",n),()=>{kt("online",e),kt("offline",n)}},Oe={isOnline:pe,isVisible:_e},Ve={initFocus:De,initReconnect:Ce},Tt=!mt.useId,ot=!Dt||"Deno"in window,Qt=t=>we()?window.requestAnimationFrame(t):setTimeout(t,1),nt=ot?d.useEffect:d.useLayoutEffect,Nt=typeof navigator<"u"&&navigator.connection,$t=!ot&&Nt&&(["slow-2g","2g"].includes(Nt.effectiveType)||Nt.saveData),wt=t=>{if($(t))try{t=t()}catch{t=""}const e=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?vt(t):"",[t,e]};let be=0;const at=()=>++be,Zt=0,te=1,ee=2,Le=3;var X={__proto__:null,ERROR_REVALIDATE_EVENT:Le,FOCUS_EVENT:Zt,MUTATE_EVENT:ee,RECONNECT_EVENT:te};async function Ht(...t){const[e,n,i,s]=t,o=j({populateCache:!0,throwOnError:!0},typeof s=="boolean"?{revalidate:s}:s||{});let f=o.populateCache;const g=o.rollbackOnError;let v=o.optimisticData;const D=L=>typeof g=="function"?g(L):g!==!1,T=o.throwOnError;if($(n)){const L=n,w=[],F=e.keys();for(const m of F)!/^\$(inf|sub)\$/.test(m)&&L(e.get(m)._k)&&w.push(m);return Promise.all(w.map(_))}return _(n);async function _(L){const[w]=wt(L);if(!w)return;const[F,m]=qt(e,w),[K,r,I,x]=Y.get(e),C=()=>{const W=K[w];return($(o.revalidate)?o.revalidate(F().data,L):o.revalidate!==!1)&&(delete I[w],delete x[w],W&&W[0])?W[0](ee).then(()=>F().data):F().data};if(t.length<3)return C();let O=i,M;const G=at();r[w]=[G,0];const E=!a(v),B=F(),N=B.data,J=B._c,Q=a(J)?N:J;if(E&&(v=$(v)?v(Q,N):v,m({data:v,_c:Q})),$(O))try{O=O(Q)}catch(W){M=W}if(O&&Te(O))if(O=await O.catch(W=>{M=W}),G!==r[w][0]){if(M)throw M;return O}else M&&E&&D(M)&&(f=!0,m({data:Q,_c:b}));if(f&&!M)if($(f)){const W=f(O,Q);m({data:W,error:b,_c:b})}else m({data:O,error:b,_c:b});if(r[w][1]=at(),Promise.resolve(C()).then(()=>{m({_c:b})}),M){if(T)throw M;return}return O}}const jt=(t,e)=>{for(const n in t)t[n][0]&&t[n][0](e)},Ae=(t,e)=>{if(!Y.has(t)){const n=j(Ve,e),i={},s=Ht.bind(b,t);let o=et;const f={},g=(T,_)=>{const L=f[T]||[];return f[T]=L,L.push(_),()=>L.splice(L.indexOf(_),1)},v=(T,_,L)=>{t.set(T,_);const w=f[T];if(w)for(const F of w)F(_,L)},D=()=>{if(!Y.has(t)&&(Y.set(t,[i,{},{},{},s,v,g]),!ot)){const T=n.initFocus(setTimeout.bind(b,jt.bind(b,i,Zt))),_=n.initReconnect(setTimeout.bind(b,jt.bind(b,i,te)));o=()=>{T&&T(),_&&_(),Y.delete(t)}}};return D(),[t,s,D,o]}return[t,Y.get(t)[4]]},ye=(t,e,n,i,s)=>{const o=n.errorRetryCount,f=s.retryCount,g=~~((Math.random()+.5)*(1<<(f<8?f:8)))*n.errorRetryInterval;!a(o)&&f>o||setTimeout(i,g,s)},Ie=(t,e)=>vt(t)==vt(e),[ne,Ne]=Ae(new Map),Me=j({onLoadingSlow:et,onSuccess:et,onError:et,onErrorRetry:ye,onDiscarded:et,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:$t?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:$t?5e3:3e3,compare:Ie,isPaused:()=>!1,cache:ne,mutate:Ne,fallback:{}},Oe),Fe=(t,e)=>{const n=j(t,e);if(e){const{use:i,fallback:s}=t,{use:o,fallback:f}=e;i&&o&&(n.use=i.concat(o)),s&&f&&(n.fallback=j(s,f))}return n},xe=d.createContext({}),We="$inf$",re=Dt&&window.__SWR_DEVTOOLS_USE__,Ue=re?window.__SWR_DEVTOOLS_USE__:[],ke=()=>{re&&(window.__SWR_DEVTOOLS_REACT__=mt)},se=t=>$(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],oe=()=>j(Me,d.useContext(xe)),Pe=t=>(e,n,i)=>t(e,n&&((...o)=>{const[f]=wt(e),[,,,g]=Y.get(ne);if(f.startsWith(We))return n(...o);const v=g[f];return a(v)?n(...o):(delete g[f],v)}),i),qe=Ue.concat(Pe),ie=t=>function(...n){const i=oe(),[s,o,f]=se(n),g=Fe(i,f);let v=t;const{use:D}=g,T=(D||[]).concat(qe);for(let _=T.length;_--;)v=T[_](v);return v(s,o||g.fetcher||null,g)},ae=(t,e,n)=>{const i=e[t]||(e[t]=[]);return i.push(n),()=>{const s=i.indexOf(n);s>=0&&(i[s]=i[i.length-1],i.pop())}},He=(t,e)=>(...n)=>{const[i,s,o]=se(n),f=(o.use||[]).concat(e);return t(i,s,{...o,use:f})};ke();const zt=mt.use||(t=>{if(t.status==="pending")throw t;if(t.status==="fulfilled")return t.value;throw t.status==="rejected"?t.reason:(t.status="pending",t.then(e=>{t.status="fulfilled",t.value=e},e=>{t.status="rejected",t.reason=e}),t)}),Mt={dedupe:!0},$e=(t,e,n)=>{const{cache:i,compare:s,suspense:o,fallbackData:f,revalidateOnMount:g,revalidateIfStale:v,refreshInterval:D,refreshWhenHidden:T,refreshWhenOffline:_,keepPreviousData:L}=n,[w,F,m,K]=Y.get(i),[r,I]=wt(t),x=d.useRef(!1),C=d.useRef(!1),O=d.useRef(r),M=d.useRef(e),G=d.useRef(n),E=()=>G.current,B=()=>E().isVisible()&&E().isOnline(),[N,J,Q,W]=qt(i,r),H=d.useRef({}).current,Ct=a(f)?n.fallback[r]:f,ut=(u,c)=>{for(const h in H){const l=h;if(l==="data"){if(!s(u[l],c[l])&&(!a(u[l])||!s(tt,c[l])))return!1}else if(c[l]!==u[l])return!1}return!0},ct=d.useMemo(()=>{const u=!r||!e?!1:a(g)?E().isPaused()||o?!1:a(v)?!0:v:g,c=S=>{const A=j(S);return delete A._k,u?{isValidating:!0,isLoading:!0,...A}:A},h=N(),l=W(),V=c(h),q=h===l?V:c(l);let R=V;return[()=>{const S=c(N());return ut(S,R)?(R.data=S.data,R.isLoading=S.isLoading,R.isValidating=S.isValidating,R.error=S.error,R):(R=S,S)},()=>q]},[i,r]),U=Xt.useSyncExternalStore(d.useCallback(u=>Q(r,(c,h)=>{ut(h,c)||u()}),[i,r]),ct[0],ct[1]),lt=!x.current,Ot=w[r]&&w[r].length>0,k=U.data,P=a(k)?Ct:k,Z=U.error,ft=d.useRef(P),tt=L?a(k)?ft.current:k:P,dt=Ot&&!a(Z)?!1:lt&&!a(g)?g:E().isPaused()?!1:o?a(P)?!1:v:a(P)||v,Et=!!(r&&e&&lt&&dt),Vt=a(U.isValidating)?Et:U.isValidating,bt=a(U.isLoading)?Et:U.isLoading,z=d.useCallback(async u=>{const c=M.current;if(!r||!c||C.current||E().isPaused())return!1;let h,l,V=!0;const q=u||{},R=!m[r]||!q.dedupe,S=()=>Tt?!C.current&&r===O.current&&x.current:r===O.current,A={isValidating:!1,isLoading:!1},ht=()=>{J(A)},gt=()=>{const p=m[r];p&&p[1]===l&&delete m[r]},St={isValidating:!0};a(N().data)&&(St.isLoading=!0);try{if(R&&(J(St),n.loadingTimeout&&a(N().data)&&setTimeout(()=>{V&&S()&&E().onLoadingSlow(r,n)},n.loadingTimeout),m[r]=[c(I),at()]),[h,l]=m[r],h=await h,R&&setTimeout(gt,n.dedupingInterval),!m[r]||m[r][1]!==l)return R&&S()&&E().onDiscarded(r),!1;A.error=b;const p=F[r];if(!a(p)&&(l<=p[0]||l<=p[1]||p[1]===0))return ht(),R&&S()&&E().onDiscarded(r),!1;const y=N().data;A.data=s(y,h)?y:h,R&&S()&&E().onSuccess(h,r,n)}catch(p){gt();const y=E(),{shouldRetryOnError:rt}=y;y.isPaused()||(A.error=p,R&&S()&&(y.onError(p,r,y),(rt===!0||$(rt)&&rt(p))&&(!E().revalidateOnFocus||!E().revalidateOnReconnect||B())&&y.onErrorRetry(p,r,y,Lt=>{const st=w[r];st&&st[0]&&st[0](X.ERROR_REVALIDATE_EVENT,Lt)},{retryCount:(q.retryCount||0)+1,dedupe:!0})))}return V=!1,ht(),!0},[r,i]),Rt=d.useCallback((...u)=>Ht(i,O.current,...u),[]);if(nt(()=>{M.current=e,G.current=n,a(k)||(ft.current=k)}),nt(()=>{if(!r)return;const u=z.bind(b,Mt);let c=0;const l=ae(r,w,(V,q={})=>{if(V==X.FOCUS_EVENT){const R=Date.now();E().revalidateOnFocus&&R>c&&B()&&(c=R+E().focusThrottleInterval,u())}else if(V==X.RECONNECT_EVENT)E().revalidateOnReconnect&&B()&&u();else{if(V==X.MUTATE_EVENT)return z();if(V==X.ERROR_REVALIDATE_EVENT)return z(q)}});return C.current=!1,O.current=r,x.current=!0,J({_k:I}),dt&&(a(P)||ot?u():Qt(u)),()=>{C.current=!0,l()}},[r]),nt(()=>{let u;function c(){const l=$(D)?D(N().data):D;l&&u!==-1&&(u=setTimeout(h,l))}function h(){!N().error&&(T||E().isVisible())&&(_||E().isOnline())?z(Mt).then(c):c()}return c(),()=>{u&&(clearTimeout(u),u=-1)}},[D,T,_,r]),d.useDebugValue(tt),o&&a(P)&&r){if(!Tt&&ot)throw new Error("Fallback data is required when using suspense in SSR.");M.current=e,G.current=n,C.current=!1;const u=K[r];if(!a(u)){const c=Rt(u);zt(c)}if(a(Z)){const c=z(Mt);a(tt)||(c.status="fulfilled",c.value=!0),zt(c)}else throw Z}return{mutate:Rt,get data(){return H.data=!0,tt},get error(){return H.error=!0,Z},get isValidating(){return H.isValidating=!0,Vt},get isLoading(){return H.isLoading=!0,bt}}},je=ie($e),Kt=mt.use||(t=>{if(t.status==="pending")throw t;if(t.status==="fulfilled")return t.value;throw t.status==="rejected"?t.reason:(t.status="pending",t.then(e=>{t.status="fulfilled",t.value=e},e=>{t.status="rejected",t.reason=e}),t)}),Ft={dedupe:!0},ze=(t,e,n)=>{const{cache:i,compare:s,suspense:o,fallbackData:f,revalidateOnMount:g,revalidateIfStale:v,refreshInterval:D,refreshWhenHidden:T,refreshWhenOffline:_,keepPreviousData:L}=n,[w,F,m,K]=Y.get(i),[r,I]=wt(t),x=d.useRef(!1),C=d.useRef(!1),O=d.useRef(r),M=d.useRef(e),G=d.useRef(n),E=()=>G.current,B=()=>E().isVisible()&&E().isOnline(),[N,J,Q,W]=qt(i,r),H=d.useRef({}).current,Ct=a(f)?n.fallback[r]:f,ut=(u,c)=>{for(const h in H){const l=h;if(l==="data"){if(!s(u[l],c[l])&&(!a(u[l])||!s(tt,c[l])))return!1}else if(c[l]!==u[l])return!1}return!0},ct=d.useMemo(()=>{const u=!r||!e?!1:a(g)?E().isPaused()||o?!1:a(v)?!0:v:g,c=S=>{const A=j(S);return delete A._k,u?{isValidating:!0,isLoading:!0,...A}:A},h=N(),l=W(),V=c(h),q=h===l?V:c(l);let R=V;return[()=>{const S=c(N());return ut(S,R)?(R.data=S.data,R.isLoading=S.isLoading,R.isValidating=S.isValidating,R.error=S.error,R):(R=S,S)},()=>q]},[i,r]),U=Xt.useSyncExternalStore(d.useCallback(u=>Q(r,(c,h)=>{ut(h,c)||u()}),[i,r]),ct[0],ct[1]),lt=!x.current,Ot=w[r]&&w[r].length>0,k=U.data,P=a(k)?Ct:k,Z=U.error,ft=d.useRef(P),tt=L?a(k)?ft.current:k:P,dt=Ot&&!a(Z)?!1:lt&&!a(g)?g:E().isPaused()?!1:o?a(P)?!1:v:a(P)||v,Et=!!(r&&e&&lt&&dt),Vt=a(U.isValidating)?Et:U.isValidating,bt=a(U.isLoading)?Et:U.isLoading,z=d.useCallback(async u=>{const c=M.current;if(!r||!c||C.current||E().isPaused())return!1;let h,l,V=!0;const q=u||{},R=!m[r]||!q.dedupe,S=()=>Tt?!C.current&&r===O.current&&x.current:r===O.current,A={isValidating:!1,isLoading:!1},ht=()=>{J(A)},gt=()=>{const p=m[r];p&&p[1]===l&&delete m[r]},St={isValidating:!0};a(N().data)&&(St.isLoading=!0);try{if(R&&(J(St),n.loadingTimeout&&a(N().data)&&setTimeout(()=>{V&&S()&&E().onLoadingSlow(r,n)},n.loadingTimeout),m[r]=[c(I),at()]),[h,l]=m[r],h=await h,R&&setTimeout(gt,n.dedupingInterval),!m[r]||m[r][1]!==l)return R&&S()&&E().onDiscarded(r),!1;A.error=b;const p=F[r];if(!a(p)&&(l<=p[0]||l<=p[1]||p[1]===0))return ht(),R&&S()&&E().onDiscarded(r),!1;const y=N().data;A.data=s(y,h)?y:h,R&&S()&&E().onSuccess(h,r,n)}catch(p){gt();const y=E(),{shouldRetryOnError:rt}=y;y.isPaused()||(A.error=p,R&&S()&&(y.onError(p,r,y),(rt===!0||$(rt)&&rt(p))&&(!E().revalidateOnFocus||!E().revalidateOnReconnect||B())&&y.onErrorRetry(p,r,y,Lt=>{const st=w[r];st&&st[0]&&st[0](X.ERROR_REVALIDATE_EVENT,Lt)},{retryCount:(q.retryCount||0)+1,dedupe:!0})))}return V=!1,ht(),!0},[r,i]),Rt=d.useCallback((...u)=>Ht(i,O.current,...u),[]);if(nt(()=>{M.current=e,G.current=n,a(k)||(ft.current=k)}),nt(()=>{if(!r)return;const u=z.bind(b,Ft);let c=0;const l=ae(r,w,(V,q={})=>{if(V==X.FOCUS_EVENT){const R=Date.now();E().revalidateOnFocus&&R>c&&B()&&(c=R+E().focusThrottleInterval,u())}else if(V==X.RECONNECT_EVENT)E().revalidateOnReconnect&&B()&&u();else{if(V==X.MUTATE_EVENT)return z();if(V==X.ERROR_REVALIDATE_EVENT)return z(q)}});return C.current=!1,O.current=r,x.current=!0,J({_k:I}),dt&&(a(P)||ot?u():Qt(u)),()=>{C.current=!0,l()}},[r]),nt(()=>{let u;function c(){const l=$(D)?D(N().data):D;l&&u!==-1&&(u=setTimeout(h,l))}function h(){!N().error&&(T||E().isVisible())&&(_||E().isOnline())?z(Ft).then(c):c()}return c(),()=>{u&&(clearTimeout(u),u=-1)}},[D,T,_,r]),d.useDebugValue(tt),o&&a(P)&&r){if(!Tt&&ot)throw new Error("Fallback data is required when using suspense in SSR.");M.current=e,G.current=n,C.current=!1;const u=K[r];if(!a(u)){const c=Rt(u);Kt(c)}if(a(Z)){const c=z(Ft);a(tt)||(c.status="fulfilled",c.value=!0),Kt(c)}else throw Z}return{mutate:Rt,get data(){return H.data=!0,tt},get error(){return H.error=!0,Z},get isValidating(){return H.isValidating=!0,Vt},get isLoading(){return H.isLoading=!0,bt}}},Ke=ie(ze),Gt=Tt?t=>{t()}:mt.startTransition,Ge=t=>{const[,e]=d.useState({}),n=d.useRef(!1),i=d.useRef(t),s=d.useRef({data:!1,error:!1,isValidating:!1}),o=d.useCallback(f=>{let g=!1;const v=i.current;for(const D in f){const T=D;v[T]!==f[T]&&(v[T]=f[T],s.current[T]&&(g=!0))}g&&!n.current&&e({})},[]);return nt(()=>(n.current=!1,()=>{n.current=!0})),[i,s.current,o]},Be=()=>(t,e,n={})=>{const{mutate:i}=oe(),s=d.useRef(t),o=d.useRef(e),f=d.useRef(n),g=d.useRef(0),[v,D,T]=Ge({data:b,error:b,isMutating:!1}),_=v.current,L=d.useCallback(async(F,m)=>{const[K,r]=wt(s.current);if(!o.current)throw new Error("Can’t trigger the mutation: missing fetcher.");if(!K)throw new Error("Can’t trigger the mutation: missing key.");const I=j(j({populateCache:!1,throwOnError:!0},f.current),m),x=at();g.current=x,T({isMutating:!0});try{const C=await i(K,o.current(r,{arg:F}),j(I,{throwOnError:!0}));return g.current<=x&&(Gt(()=>T({data:C,isMutating:!1,error:void 0})),I.onSuccess==null||I.onSuccess.call(I,C,K,I)),C}catch(C){if(g.current<=x&&(Gt(()=>T({error:C,isMutating:!1})),I.onError==null||I.onError.call(I,C,K,I),I.throwOnError))throw C}},[]),w=d.useCallback(()=>{g.current=at(),T({data:b,error:b,isMutating:!1})},[]);return nt(()=>{s.current=t,o.current=e,f.current=n}),{trigger:L,reset:w,get data(){return D.data=!0,_.data},get error(){return D.error=!0,_.error},get isMutating(){return D.isMutating=!0,_.isMutating}}},Je=He(Ke,Be);function Xe(){const t=Bt.models.list,{data:e,isLoading:n,error:i,isValidating:s}=je(t,ue);return d.useMemo(()=>{var f;return{modelList:(e==null?void 0:e.payload)||[],modelListLoading:n,modelListError:i,modelListValidating:s,modelListEmpty:!n&&!((f=e==null?void 0:e.payload)!=null&&f.length)}},[e,n,i,s])}const Qe=()=>{const t=Bt.models.create;async function e(s,{arg:o}){return ce(s,o)}const{trigger:n,isMutating:i}=Je(t,e,{onSuccess:(s,o)=>console.log("onSuccess",s,o),onError:(s,o)=>console.log("onError",s,o)});return{trigger:n,isMutating:i}};export{Qe as a,Xe as u};
